# Inspect

The `inspect` command helps you identify which resolvers marked with `@resolver` directive are not yet implemented or still contain stub implementations.

```sh
npx axolotl inspect -s ./schema.graphql -r ./lib/resolvers.js
```

## What It Does

The inspect command:

1. **Finds all fields** marked with `@resolver` directive in your schema
2. **Checks implementation status** of each resolver:
   - **Missing**: Resolver doesn't exist in your resolvers object
   - **Stub**: Resolver exists but throws `"Not implemented"` error
3. **Reports only unimplemented resolvers** - fully implemented resolvers are not reported

This is different from checking all schema fields - inspect **only** checks fields you've explicitly marked with `@resolver`, making it perfect for tracking your implementation progress.

## Prerequisites

- Build your project before running `inspect` (run `npm run build` or `tsc`)
- The resolvers file must export a default value created with `createResolvers`
- Schema must define the `@resolver` directive

## Example

### Schema with @resolver Directives

```graphql filename="./schema.graphql"
directive @resolver on FIELD_DEFINITION

type User {
  _id: String!
  username: String!
  email: String
}

type Query {
  me: User @resolver
  users: [User!] @resolver
  hello: String
}

type Mutation {
  login(username: String!, password: String!): String! @resolver
  register(username: String!, password: String!): String! @resolver
}

schema {
  query: Query
  mutation: Mutation
}
```

### Resolvers File

```ts filename="./src/resolvers.ts"
import { createResolvers } from '@/src/axolotl.js';

const resolvers = createResolvers({
  Query: {
    me: async ([, , context]) => {
      return getUserById(context.userId);
    },
    users: async () => {
      // This is a stub - not actually implemented
      throw new Error('Not implemented: Query.users');
    },
    // Query.hello is NOT marked with @resolver, so it won't be checked
    hello: () => 'Hello World!',
  },
  // Mutation resolvers are completely missing
});

export default resolvers;
```

### Running Inspect

```sh
npx axolotl inspect -s ./schema.graphql -r ./lib/resolvers.js
```

### Output

```sh
Resolvers that need implementation:

⚠️ Query.users - throws "Not implemented"
❌ Mutation.login - not found
❌ Mutation.register - not found

Total: 3 resolver(s) to implement
```

## Output Explanation

The inspect command provides clear, actionable output:

- **✅ Success** - If all `@resolver` fields are implemented, you'll see:
  ```
  ✓ All @resolver directive fields are implemented!
  ```

- **⚠️ Stub Implementation** - Resolver exists but throws "Not implemented" error
  - These are typically generated by `npx axolotl resolvers` command
  - You need to replace the stub with actual implementation

- **❌ Missing Resolver** - No resolver function exists for this field
  - The field is completely missing from your resolvers object
  - You need to add the resolver function

## Integration with Workflow

The inspect command integrates perfectly with the Axolotl development workflow:

1. **Add @resolver directives** to schema fields that need implementation:
   ```graphql
   type Query {
     users: [User!] @resolver
   }
   ```

2. **Run build** to update TypeScript types:
   ```sh
   npx @aexol/axolotl build
   ```

3. **Generate resolver stubs** (optional):
   ```sh
   npx @aexol/axolotl resolvers
   ```
   This creates placeholder files with `throw new Error('Not implemented')`

4. **Implement resolvers** - Replace stubs with actual logic

5. **Run inspect** to verify completion:
   ```sh
   npx @aexol/axolotl inspect
   ```

6. **Repeat** until inspect reports all resolvers are implemented ✅

## Options

- `-s, --schema <path>` - Path to schema file (default: `./schema.graphql`)
- `-r, --resolvers <path>` - Path to transpiled resolvers file (default: `./lib/resolvers.js`)

**Note**: The resolvers path should point to the **compiled JavaScript file** (e.g., `./lib/resolvers.js`), not the TypeScript source (e.g., `./src/resolvers.ts`).

## Exit Codes

- `0` - All `@resolver` fields are implemented
- `1` - Some resolvers are missing or stubbed

This makes inspect useful in CI/CD pipelines to enforce that all marked resolvers are implemented before deployment.

## LLM-Friendly Output

The inspect command is designed to provide clear, structured output that's easy for both humans and AI assistants to parse and act upon. When an LLM encounters unimplemented resolvers, it can:

1. Identify exactly which resolvers need implementation
2. Distinguish between missing and stubbed resolvers
3. Navigate directly to the relevant resolver files
4. Implement the required functionality

## Tips

- **Use @resolver directive intentionally** - Only mark fields that need custom resolver logic
- **Fields without @resolver** - These rely on default GraphQL resolution and won't be checked
- **Combine with `resolvers` command** - Generate stubs first, then implement them
- **Check before commits** - Run inspect to ensure you haven't forgotten any implementations
