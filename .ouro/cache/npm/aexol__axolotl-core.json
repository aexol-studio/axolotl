{"pkg":"@aexol/axolotl-core","readme":"# @aexol/axolotl-core\n\nAxolotl’s core library. It provides the type-safe, schema-first building blocks used by adapters and apps.\n\n- Axolotl runtime primitives (`Axolotl`, `AxolotlAdapter`)\n- Helpers to create resolvers, scalars, directives, and apply middleware\n- Utilities for schema inspection, federation, model generation, and chaos testing\n\n## Key APIs\n\n- `Axolotl(adapter)<Models, Scalars, Directives>()` – bootstraps a project with a selected adapter\n- `createResolvers`, `createScalars`, `createDirectives`, `applyMiddleware` – author resolvers and plug middleware\n- `setSourceTypeFromResolver` – infer source type from a resolver\n- `generateModels`, `inspectResolvers`, `createSuperGraph`, `chaos` – utilities used by the CLI\n\nSee `packages/core/index.ts:1` for exports and `packages/core/types.ts:1` for types.\n\n## When To Use\n\n- Building GraphQL servers with strong typing over your schema\n- Sharing common logic across adapters (Yoga, Apollo) and examples\n\n## Develop\n\n- Build: `npm run build --ws --if-present`\n- Test: `npm test`\n- Lint: `npx eslint packages/core`\n\n---\n\n### Minimal Example (with an adapter)\n\n```ts\nimport { Axolotl } from '@aexol/axolotl-core';\nimport { graphqlYogaAdapter } from '@aexol/axolotl-graphql-yoga';\n\nconst { createResolvers } = Axolotl(graphqlYogaAdapter)<{\n  Query: { hello: string };\n}>();\n\nexport const resolvers = createResolvers({\n  Query: {\n    hello: async () => 'world',\n  },\n});\n```\n\n## Scalars\n\nAxolotl lets you define GraphQL custom scalars in a type‑safe way and pass them to your adapter.\n\n1) Declare the scalar in your SDL and regenerate models if you use codegen\n\n```graphql\nscalar URL\n\ntype Beer {\n  url: URL\n}\n```\n\n2) Type your scalar map via the second generic argument to `Axolotl` and implement with `createScalars`\n\n```ts\nimport { Axolotl } from '@aexol/axolotl-core';\nimport { GraphQLScalarType, Kind } from 'graphql';\nimport { graphqlYogaAdapter } from '@aexol/axolotl-graphql-yoga';\n\ntype ScalarModels = { URL: unknown };\n\nconst { createScalars, createResolvers } = Axolotl(graphqlYogaAdapter)<\n  { Query: { ping: string } },\n  ScalarModels\n>();\n\nconst scalars = createScalars({\n  URL: new GraphQLScalarType({\n    name: 'URL',\n    serialize(value) {\n      return new URL(String(value)).toString();\n    },\n    parseValue(value) {\n      return value == null ? value : new URL(String(value));\n    },\n    parseLiteral(ast) {\n      if (ast.kind !== Kind.STRING) return null;\n      try {\n        return new URL(ast.value);\n      } catch {\n        return null;\n      }\n    },\n  }),\n});\n\nconst resolvers = createResolvers({\n  Query: { ping: () => 'pong' },\n});\n\n// Pass scalars to the adapter alongside resolvers\ngraphqlYogaAdapter({ resolvers, scalars });\n```\n\nNotes\n- `createScalars({...})` is typed: keys must match your `ScalarModels` keys.\n- Provide at least `serialize` and `parseValue`; `parseLiteral` is recommended for literal input handling.\n- All adapters merge scalars into the executable schema next to your resolvers.\n\n## Directives\n\nAxolotl lets adapters apply GraphQL directives by mapping them to field/config transforms.\n\n- The third generic to `Axolotl(...)<Models, Scalars, Directives>()` controls the available directive names.\n- Use `createDirectives` to define mappers. Each directive is an adapter‑specific function that returns a `SchemaMapper` (see adapter docs).\n- Pass the resulting `directives` object to your adapter along with `resolvers` and `scalars`.\n\nExample (Yoga adapter shown):\n\n```ts\nimport { Axolotl } from '@aexol/axolotl-core';\nimport { graphqlYogaWithContextAdapter } from '@aexol/axolotl-graphql-yoga';\nimport { defaultFieldResolver } from 'graphql';\nimport { MapperKind } from '@graphql-tools/utils';\n\ntype DirModels = { auth: { args: Record<string, never> } };\n\nconst { createDirectives, createResolvers } = Axolotl(graphqlYogaWithContextAdapter())<\n  { Query: { secret: string } },\n  {},\n  DirModels\n>();\n\nconst directives = createDirectives({\n  auth: (schema, getDirective) => ({\n    [MapperKind.OBJECT_FIELD]: (fieldConfig) => {\n      const has = getDirective(schema, fieldConfig, 'auth');\n      if (!has) return fieldConfig;\n      const { resolve = defaultFieldResolver } = fieldConfig as any;\n      return {\n        ...fieldConfig,\n        resolve: async (parent: any, args: any, ctx: any, info: any) => {\n          if (!ctx.userId) throw new Error('Not authorized');\n          return resolve(parent, args, ctx, info);\n        },\n      } as any;\n    },\n  }),\n});\n\nconst resolvers = createResolvers({\n  Query: { secret: () => 'top secret' },\n});\n\n// Include directives when creating the server\ngraphqlYogaWithContextAdapter()({ resolvers, directives });\n```\n\nNotes\n- Directive implementations are adapter‑specific. See adapter READMEs for types and context signatures.\n","homepage":null,"repository":null}