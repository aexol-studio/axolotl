# Frontend Development Guide

## Overview

This frontend communicates with the Axolotl GraphQL backend using **Zeus**, a type-safe GraphQL client that is auto-generated from the schema.

## Critical Rules for Frontend Development

1. **ALWAYS use Zeus** for GraphQL communication - never write raw GraphQL queries
2. **ALWAYS define Selectors** for reusable query shapes
3. **ALWAYS use `FromSelector`** to derive TypeScript types from selectors
4. **NEVER manually duplicate backend types** - derive them from selectors
5. **Use `$` function** for GraphQL variables when values come from user input or props

---

## Zeus Setup

Zeus is generated by Axolotl and located in `../src/zeus/`. Import what you need:

```typescript
import { Chain, Selector, FromSelector, $ } from '../../src/zeus/index';
```

### Creating a Client

```typescript
import { Chain } from '../../src/zeus/index';

export const createGqlClient = (token?: string) => {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  if (token) {
    headers['token'] = token;
  }
  return Chain('/graphql', { headers });
};

// Default client without auth
export const gql = createGqlClient();
```

---

## Using Selectors

Selectors define the shape of your GraphQL queries in a type-safe way. They are reusable and ensure consistency across your application.

### Defining a Selector

```typescript
import { Selector } from '../../src/zeus/index';

// Define what fields you want from a Todo
const todoSelector = Selector('Todo')({
  _id: true,
  content: true,
  done: true,
});

// Define what fields you want from a User
const userSelector = Selector('User')({
  _id: true,
  username: true,
});
```

### Using Selectors in Queries

```typescript
const gql = createGqlClient(token);

// Use the selector in a query
const data = await gql('query')({
  user: {
    todos: todoSelector,
    me: userSelector,
  },
});
```

---

## Deriving Types with FromSelector

**CRITICAL:** Never manually define types that mirror backend types. Instead, derive them from selectors using `FromSelector`.

### Basic Usage

```typescript
import { Selector, FromSelector } from '../../src/zeus/index';

// 1. Define the selector
const todoSelector = Selector('Todo')({
  _id: true,
  content: true,
  done: true,
});

// 2. Derive the type from the selector
type Todo = FromSelector<typeof todoSelector, 'Todo'>;
// Todo is now: { _id: string; content: string; done: boolean | null }

// 3. Use in your React components
function TodoItem({ todo }: { todo: Todo }) {
  return <div>{todo.content}</div>;
}
```

### Complete Pattern

```typescript
import { Selector, FromSelector, Chain } from '../../src/zeus/index';

// Selectors (define once, reuse everywhere)
export const todoSelector = Selector('Todo')({
  _id: true,
  content: true,
  done: true,
});

export const userSelector = Selector('User')({
  _id: true,
  username: true,
});

// Types derived from selectors (automatic type safety!)
export type Todo = FromSelector<typeof todoSelector, 'Todo'>;
export type User = FromSelector<typeof userSelector, 'User'>;
```

---

## GraphQL Variables with `$`

Use the `$` function to define GraphQL variables. This is essential for:

- User input values
- Dynamic IDs
- Values passed as props
- Any value that should be parameterized

### Basic Variable Usage

```typescript
import { $, Chain } from '../../src/zeus/index';

const gql = Chain('/graphql', { headers: { 'Content-Type': 'application/json' } });

// Define variables with $ and provide values in the second argument
const result = await gql('mutation')(
  {
    login: [
      {
        username: $('username', 'String!'),
        password: $('password', 'String!'),
      },
      true, // return the scalar value directly
    ],
  },
  {
    variables: {
      username: 'john', // type-safe: must be string
      password: 'secret123', // type-safe: must be string
    },
  },
);
```

### Variable Syntax

The `$` function takes two arguments:

1. **Variable name** - The name of the variable (used in the variables object)
2. **GraphQL type** - The type of the variable (e.g., `'String!'`, `'Int'`, `'[String!]!'`)

```typescript
// Required string
$('name', 'String!');

// Optional integer
$('count', 'Int');

// Required array of strings
$('ids', '[String!]!');

// Optional array
$('tags', '[String]');
```

### Variables with Selectors

```typescript
import { $, Selector, FromSelector, Chain } from '../../src/zeus/index';

const todoSelector = Selector('Todo')({
  _id: true,
  content: true,
  done: true,
});

type Todo = FromSelector<typeof todoSelector, 'Todo'>;

async function getTodoById(id: string): Promise<Todo | null> {
  const gql = Chain('/graphql', { headers: { token: getToken() } });

  const data = await gql('query')(
    {
      user: {
        todo: [{ _id: $('todoId', 'String!') }, todoSelector],
      },
    },
    {
      variables: {
        todoId: id,
      },
    },
  );

  return data.user?.todo ?? null;
}
```

### When to Use Variables vs Inline Values

**Use variables (`$`) when:**

- Value comes from user input
- Value comes from component props
- Value is dynamic (changes at runtime)
- You want to reuse the query with different values

**Use inline values when:**

- Value is truly constant (e.g., `true` for a boolean field selection)
- Value is hardcoded and never changes

```typescript
// GOOD: Use variable for dynamic content
await gql('mutation')(
  {
    user: {
      createTodo: [{ content: $('content', 'String!') }, true],
    },
  },
  {
    variables: { content: userInputContent },
  },
);

// ALSO FINE: Inline for simple cases where reuse isn't needed
await gql('mutation')({
  user: {
    createTodo: [{ content: 'Buy groceries' }, true],
  },
});
```

---

## Common Patterns

### Mutations with Arguments

```typescript
// Creating a todo with variables
await gql('mutation')(
  {
    user: {
      createTodo: [{ content: $('content', 'String!') }, true],
    },
  },
  {
    variables: { content: 'New task' },
  },
);

// Login with variables
const data = await gql('mutation')(
  {
    login: [
      {
        username: $('username', 'String!'),
        password: $('password', 'String!'),
      },
      true,
    ],
  },
  {
    variables: { username, password },
  },
);
const token = data.login;
```

### Nested Selectors

```typescript
const authorizedQuerySelector = Selector('AuthorizedUserQuery')({
  me: userSelector,
  todos: todoSelector,
});

// Use in query
const data = await gql('query')({
  user: authorizedQuerySelector,
});
```

### Operations with Object Return Types

```typescript
// When mutation returns an object, use a selector
const todoOpsSelector = Selector('TodoOps')({
  markDone: true,
});

await gql('mutation')(
  {
    user: {
      todoOps: [{ _id: $('id', 'String!') }, todoOpsSelector],
    },
  },
  {
    variables: { id: todoId },
  },
);
```

---

## Recommended File Structure

```
frontend/
├── src/
│   ├── api.ts           # Chain client creation
│   ├── selectors.ts     # All selectors and derived types
│   ├── hooks/
│   │   ├── useAuth.ts   # Auth-related queries/mutations
│   │   └── useTodos.ts  # Todo-related queries/mutations
│   └── components/
│       └── ...
```

### Example: selectors.ts

```typescript
import { Selector, FromSelector } from '../../src/zeus/index';

// ============ Todo ============
export const todoSelector = Selector('Todo')({
  _id: true,
  content: true,
  done: true,
});
export type Todo = FromSelector<typeof todoSelector, 'Todo'>;

// ============ User ============
export const userSelector = Selector('User')({
  _id: true,
  username: true,
});
export type User = FromSelector<typeof userSelector, 'User'>;

// ============ Composite Selectors ============
export const authorizedQuerySelector = Selector('AuthorizedUserQuery')({
  me: userSelector,
  todos: todoSelector,
});
```

### Example: hooks/useTodos.ts

```typescript
import { useState, useCallback } from 'react';
import { $ } from '../../../src/zeus/index';
import { createGqlClient } from '../api';
import { Todo, todoSelector } from '../selectors';

export function useTodos(token: string | null) {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const gql = useCallback(() => createGqlClient(token || undefined), [token]);

  const fetchTodos = useCallback(async () => {
    if (!token) return;
    setIsLoading(true);
    setError(null);
    try {
      const data = await gql()('query')({
        user: {
          todos: todoSelector,
        },
      });
      if (data.user?.todos) {
        setTodos(data.user.todos);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch todos');
    } finally {
      setIsLoading(false);
    }
  }, [token, gql]);

  const createTodo = async (content: string) => {
    if (!token || !content.trim()) return false;
    setIsLoading(true);
    setError(null);
    try {
      await gql()('mutation')(
        {
          user: {
            createTodo: [{ content: $('content', 'String!') }, true],
          },
        },
        {
          variables: { content },
        },
      );
      await fetchTodos();
      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create todo');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  return { todos, isLoading, error, fetchTodos, createTodo };
}
```

---

## Best Practices

1. **Centralize selectors** - Define all selectors in one file (e.g., `selectors.ts`)
2. **Export types alongside selectors** - Keep them together for easy imports
3. **Reuse selectors** - Don't repeat field selections across queries
4. **Keep selectors minimal** - Only request fields you actually need
5. **Use variables for dynamic values** - Especially for user input and IDs
6. **Handle errors gracefully** - Wrap API calls in try/catch
7. **Use loading states** - Track loading state for better UX

---

## Troubleshooting

### Type errors after schema changes

**Solution:** Regenerate Zeus by running `npx @aexol/axolotl build` in the project root

### Zeus files not found

**Solution:** Ensure `axolotl.json` has zeus configuration and run `npx @aexol/axolotl build`

```json
{
  "zeus": [
    {
      "generationPath": "src/"
    }
  ]
}
```

### Type mismatch between frontend and backend

**Solution:** You're probably manually defining types. Use `FromSelector` instead to derive types directly from the schema.

### Variable type errors

**Solution:** Ensure the GraphQL type in `$('name', 'Type')` matches the schema. Check if the field is required (`String!`) or optional (`String`).

---

## Quick Reference

| Task                   | Code                                                     |
| ---------------------- | -------------------------------------------------------- |
| Create client          | `Chain('/graphql', { headers })`                         |
| Define selector        | `Selector('TypeName')({ field: true })`                  |
| Derive type            | `FromSelector<typeof selector, 'TypeName'>`              |
| Define variable        | `$('varName', 'String!')`                                |
| Query with selector    | `gql('query')({ field: selector })`                      |
| Mutation with args     | `gql('mutation')({ field: [{ arg: value }, selector] })` |
| Query with variables   | `gql('query')({ ... }, { variables: { ... } })`          |
| Nested field with args | `field: [{ argName: $('var', 'Type') }, selector]`       |
| Return scalar directly | `field: [{ args }, true]`                                |
